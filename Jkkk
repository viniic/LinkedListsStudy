// Vers√£o concorrente do FileIndexingPipeline
import java.io.IOException;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.Semaphore;

public class FileIndexingPipelineConcurrent {

    static final int BUFFER_CAPACITY = 50;
    static Map<String, Map<String, Integer>> fileIndex = new HashMap<>();

    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println("Uso: java FileIndexingPipelineConcurrent <arquivo1.txt> <arquivo2.txt> ...");
            return;
        }

        BoundedBuffer<FileData> readBuffer = new BoundedBuffer<>(BUFFER_CAPACITY);
        BoundedBuffer<FileData> tokenBuffer = new BoundedBuffer<>(BUFFER_CAPACITY);

        Thread readerThread = new Thread(() -> {
            for (String pathStr : args) {
                try {
                    Path path = Paths.get(pathStr);
                    String content = Files.readString(path);
                    readBuffer.insert(new FileData(path.getFileName().toString(), content));
                } catch (IOException e) {
                    System.err.println("Erro ao ler arquivo " + pathStr + ": " + e.getMessage());
                }
            }
            readBuffer.insert(null); // EOF
        });

        Thread tokenizerThread = new Thread(() -> {
            while (true) {
                FileData fileData = readBuffer.remove();
                if (fileData == null) {
                    tokenBuffer.insert(null); // Passa EOF adiante
                    break;
                }
                String[] words = fileData.content.split("\\s+");
                String newContent = String.join(",", words);
                tokenBuffer.insert(new FileData(fileData.name, newContent));
            }
        });

        Thread indexerThread = new Thread(() -> {
            while (true) {
                FileData fileData = tokenBuffer.remove();
                if (fileData == null) break;
                String[] words = fileData.content.split(",");
                synchronized (fileIndex) {
                    for (String word : words) {
                        fileIndex.putIfAbsent(word, new HashMap<>());
                        Map<String, Integer> files = fileIndex.get(word);
                        files.put(fileData.name, files.getOrDefault(fileData.name, 0) + 1);
                    }
                }
            }
        });

        readerThread.start();
        tokenizerThread.start();
        indexerThread.start();

        try {
            readerThread.join();
            tokenizerThread.join();
            indexerThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("fileIndex:");
        for (var word : fileIndex.keySet()) {
            System.out.println(word + " -> " + fileIndex.get(word));
        }
    }

    static class FileData {
        public final String name;
        public final String content;

        public FileData(String name, String content) {
            this.name = name;
            this.content = content;
        }
    }

    static class BoundedBuffer<T> {
        private final Queue<T> queue = new LinkedList<>();
        private final int capacity;
        private final Semaphore full;
        private final Semaphore empty;
        private final Object lock = new Object();

        public BoundedBuffer(int capacity) {
            this.capacity = capacity;
            this.full = new Semaphore(0);
            this.empty = new Semaphore(capacity);
        }

        public void insert(T item) {
            try {
                empty.acquire();
                synchronized (lock) {
                    queue.add(item);
                }
                full.release();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        public T remove() {
            try {
                full.acquire();
                T item;
                synchronized (lock) {
                    item = queue.poll();
                }
                empty.release();
                return item;
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return null;
            }
        }
    }
}
